---
description: 코틀린 동시성 프로그래밍 5장을 요약한 내용입니다.
---

# 5장 이터레이터, 시퀀스 그리고 프로듀서



## 이터레이터

이터레이터는 요소들의 컬렉션을 순서대로 살펴보는 데 특히 유용하다. 코틀린 이터레이터의 특성은 다음과 같다.

* 인덱스로 요소를 검색할 수 없으므로 요소는 순서대로만 액세스할 수 있다.
* 더 많은 요소가 있는지 여부를 나타내는 hasNext() 함수가 있다.
* 요소는 한 방향으로만 검색할 수 있다. 이전 요소를 검색할 방법은 없다.
* 재설정(reset)할 수 없으므로 한 번만 반복할 수 있다.

```kotlin
val iterator : Iterator<Any> = iterator {
		yield(1)
		yield(10L)
		yield("Hello")
}
```

### 이터레이터와의 상호 작용

```kotlin
fun main(args: Array<String>) {
		val iterator = iterator {
				println("yielding 1")
				println("yielding 1")
				println("yielding 1")
				println("yielding 1")
		}

		iterator.next()

		if (iterator.hasNext()) {
				println("iterator has next")
				iterator.next()
		}
}
```

hasNext()가 작동하려면 런타임은 코루틴 실행을 재개한다. 새로운 값이 나오면 함수는 true를 반환하고, 더 이상 값이 없어 이터레이터의 실행이 끝나면 함수는 false를 반환한다.

## 시퀀스

일시 중단 시퀀스는 일시 중단 이터레이터와는 상당히 다르다.

* 인덱스로 값을 가져올 수 있다.
* 상태가 저장되지 않으며, 상호 작용한 후 자동으로 재설정된다.
* 한 번의 호출로 값 그룹을 가져올 수 있다.

### 시퀀스는 상태가 없다.

일시 중단 시퀀스는 상태가 없고 사용된 후에 재설정된다. 다음 시퀀스를 살펴보자.

```kotlin
val sequence = sequence {
		for (i in 0..9) {
				println("Yielding $i")
				yield(i)
		}
}
```

다음과 같은 값을 읽어보자.

```kotlin
for main(args: Array<String>) {
		println("Requesting  index 1")
		sequence.elementAt(1)
	
		println("Requesting  index 2")
		sequence.elementAt(2)

		println("Requesting  index 3")
		sequence.elementAt(3)
}
```

이터레이터를 사용하는 것과는 달리 시퀀스는 각각의 호출마다 요소의 처음부터 실행됨을 알 수 있다.

## 프로듀서

시퀀스와 이터레이터에는 실행 중에 일시 중단할 수 없다는 제한이 있다. 이상적으로는 다른 작업이 끝나기를 기다리는 동안 일시 중단할 수 있어야 해서 이것은 대부분 큰 제약사항이다.

한계를 극복하려면 프로듀서를 사용해야 한다. 프로듀서의 사상과 사용법은 일시 중단 시퀀스나 이터레이터와 비슷하지만 약간의 차이가 있다.

* 프로듀서는 값이 생성된 후 일시 중단되며, 새로운 값이 요청될 때 다시 재개된다. 이는 일시 중단 시퀀스 및 이터레이터와 유사하다.
* 프로듀서는 특정 CoroutineContext로 생성할 수 있다.
* 전달되는 일시 중단 람다의 본문은 언제든지 일시 중단될 수 있다.
* 어느 시점에서든 일시 중단할 수 있으므로 프로듀서의 값은 일시 중단 연산에서만 수신할 수 있다.
* 채널을 사용해 작동하므로 데이터를 스트림처럼 생각할 수 있다. 요소를 수신하면 스트림에서 요소가 제거된다.

## 요약

* 필요하지 않을 때 일시 중단되는 여러 유형의 일시 중단 함수가 있다.
* 시퀀스의 몇 가지 특징은 다음과 같다. 상태 비 저장이므로 각 호출 후 자체적으로 재설정된다. 인덱스로 정보를 검색할 수 있다. 한 번에 여러 값의 그룹을 얻을 수 있다.
* 이터레이터의 몇 가지 특징은 다음과 같다. 상태가 있고, 한 방향으로만 읽을 수 있으므로 이전 요소를 검색할 수 없으며, 인덱스로 요소를 검색할 수 없다.
* 시퀀스와 이터레이터는 하나 이상의 값을 생성한 후에 일시 중단될 수 있지만 실행의 일부로 일시 중단될 수 없으므로 숫자의 시퀀스와 같은 비동기 작업이 필요 없는 데이터 소스에 적합하다.
* 시퀀스와 이터레이터는 실행 중에 일시 중단할 수 없으므로 비중단 연산에서 호출할 수 있다.
* 프로듀서는 실행하는 동안을 포함해 언제든지 중단할 수 있다.
* 프로듀서는 실행 중에 일시 중단될 수 있기 때문에, 일시 중단 연산이나 코루틴에서만 호출할 수 있다.
* 프로듀서는 채널을 사용해 데이터를 출력한다.
